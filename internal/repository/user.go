package repository

import (
	"context"
	"fmt"
	"time"

	context_db "github.com/rifkiadrn/data-elt/internal/context/db"
	"github.com/rifkiadrn/data-elt/internal/entity"
	model_db "github.com/rifkiadrn/data-elt/internal/model/db"
	"github.com/sirupsen/logrus"
)

// UserRepository implements the user repository interface
type UserRepository struct {
	Log *logrus.Logger
}

func NewUserRepository(log *logrus.Logger) UserRepository {
	return UserRepository{
		Log: log,
	}
}

// entityToDBUser converts domain entity to DB model
func (r UserRepository) entityToDBUser(e entity.User) model_db.User {
	return model_db.User{
		ID:       e.ID,
		Name:     e.Name,
		Username: e.Username,
		Password: e.Password,
		Token:    e.Token,
		IsOnline: e.IsOnline,
		LastSeen: e.LastSeen.Unix(),
		// CreatedAt and UpdatedAt are auto-generated by GORM
	}
}

// dbToEntityUser converts DB model to domain entity pointer
func (r UserRepository) dbToEntityUser(db model_db.User) *entity.User {
	return &entity.User{
		ID:        db.ID,
		Name:      db.Name,
		Username:  db.Username,
		Password:  db.Password,
		Token:     db.Token,
		IsOnline:  db.IsOnline,
		LastSeen:  time.Unix(db.LastSeen, 0),
		CreatedAt: time.Unix(db.CreatedAt, 0),
		UpdatedAt: time.Unix(db.UpdatedAt, 0),
	}
}

// Create creates a new user
func (r UserRepository) Create(ctx context.Context, user entity.User) (*entity.User, error) {
	dbUser := r.entityToDBUser(user)

	db, err := context_db.GetTx(ctx)
	if err != nil {
		return nil, err
	}

	if err := db.Create(&dbUser).Error; err != nil {
		return nil, err
	}

	return r.dbToEntityUser(dbUser), nil
}

// FindById finds a user by ID
func (r UserRepository) FindById(ctx context.Context, userID string) (*entity.User, error) {
	db, err := context_db.GetTx(ctx)
	if err != nil {
		return nil, err
	}

	var dbUser model_db.User
	if err := db.Where("id = ?", userID).First(&dbUser).Error; err != nil {
		return nil, err
	}

	return r.dbToEntityUser(dbUser), nil
}

// FindByUsername finds a user by username
func (r UserRepository) FindByUsername(ctx context.Context, username string) (*entity.User, error) {
	db, err := context_db.GetTx(ctx)
	if err != nil {
		return nil, err
	}

	var dbUser model_db.User
	if err := db.Where("username = ?", username).First(&dbUser).Error; err != nil {
		return nil, err
	}

	return r.dbToEntityUser(dbUser), nil
}

// UpdateOnlineStatus updates a user's online status
func (r UserRepository) UpdateOnlineStatus(ctx context.Context, userID string, isOnline bool) error {
	db, err := context_db.GetTx(ctx)
	if err != nil {
		return err
	}

	return db.Model(&model_db.User{}).
		Where("id = ?", userID).
		Updates(map[string]interface{}{
			"is_online": isOnline,
			"last_seen": time.Now().Unix(),
		}).Error
}

// GetOnlineUsers gets all online users
func (r UserRepository) GetOnlineUsers(ctx context.Context) ([]*entity.User, error) {
	db, err := context_db.GetTx(ctx)
	if err != nil {
		return nil, err
	}

	var dbUsers []model_db.User
	if err := db.Where("is_online = true").Find(&dbUsers).Error; err != nil {
		return nil, err
	}

	// Convert to entities
	users := make([]*entity.User, len(dbUsers))
	for i, dbUser := range dbUsers {
		users[i] = r.dbToEntityUser(dbUser)
	}

	return users, nil
}

func (r UserRepository) Update(ctx context.Context, existingUser entity.User, updatedUser entity.User) (*entity.User, error) {
	db, err := context_db.GetTx(ctx)
	if err != nil {
		return nil, err
	}

	fmt.Printf("existingUser: %+v\n", updatedUser)

	// Patch changes in updatedUser to existingUser
	user := existingUser

	if updatedUser.Name != "" {
		user.Name = updatedUser.Name
	}
	if updatedUser.Username != "" {
		user.Username = updatedUser.Username
	}
	if updatedUser.Password != "" {
		user.Password = updatedUser.Password
	}
	if updatedUser.Token != "" {
		user.Token = updatedUser.Token
	}
	user.UpdatedAt = time.Now()

	dbUser := r.entityToDBUser(user)

	if err := db.Model(&model_db.User{}).Where("id = ?", user.ID).Updates(dbUser).Error; err != nil {
		return nil, err
	}

	return r.dbToEntityUser(dbUser), nil
}
